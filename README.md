# E8 Prime Structure Toolkit

Tools for analyzing prime gap distributions through the lens of the E8 root
system and the full exceptional chain G2 < F4 < E6 < E7 < E8, plus the S(16)
half-spinor sublattice.  The pipeline starts from raw prime data, assigns each
gap an E8 root via a phase map, projects through all sublattices, computes
traces and spectra, and produces high-resolution Ulam-spiral visualizations
colored by algebraic invariants.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Prime Data](#prime-data)
3. [Building the C Programs](#building-the-c-programs)
4. [Tool Reference](#tool-reference)
   - [C Programs](#c-programs)
   - [Python Analysis Scripts](#python-analysis-scripts)
   - [Python Utility Scripts](#python-utility-scripts)
   - [SageMath Scripts](#sagemath-scripts)
5. [Workflow Examples](#workflow-examples)
6. [Output Files](#output-files)
7. [Mathematics Overview](#mathematics-overview)
8. [Troubleshooting](#troubleshooting)

---

## Prerequisites

**System:**
- GCC with OpenMP support
- libpng development headers (`sudo apt install libpng-dev`)
- ImageMagick (for PPM-to-PNG conversion: `sudo apt install imagemagick`)

**Python 3:**
```bash
pip install numpy matplotlib scipy
```

**Optional:**
- SageMath (for lattice-theoretic decoding via `e8_prime_decode.sage`)
- gmpy2, tqdm (for `e8_decoderring.py`)
- primesieve (`sudo apt install primesieve`)

---

## Prime Data

The toolkit reads primes from text files `primes1.txt` through `primes50.txt`,
each containing 2 million primes in the format used by t5k.org (space-separated,
10 per line, with a header line).  Together they provide the first 100 million
primes (up to 2,038,074,743).

### Obtaining prime data

**Option A -- Generate with primesieve and split:**
```bash
primesieve 2038074743 --print > all_primes.txt
python3 split_primes.py
```

**Option B -- Download from t5k.org:**

Download `primes1.txt` through `primes50.txt` from
https://t5k.org/lists/small/millions/ and place them in this directory.

**Option C -- Use the built-in sieve (C programs only):**

The C programs `e8_slope_viz` and `e8_f4_viz` have a built-in segmented sieve
and do not require prime files.  They generate primes on the fly by default.
Use `--from-files .` to load from files instead.

### File format

Each `primesN.txt` has a header line followed by space-separated integers,
10 per line:
```
The First 2,000,000 Primes (generated by primesieve)
2 3 5 7 11 13 17 19 23 29
31 37 41 43 47 53 59 61 67 71
...
```

The scripts use regex (`\b\d+\b`) to extract integers, so most whitespace-
delimited formats work.

---

## Building the C Programs

```bash
make all                  # Build everything
make e8_slope_viz         # E8 slope visualization (requires libpng)
make e8_f4_viz            # F4 crystalline grid with PNG output (requires libpng)
make f4_crystalline_grid  # F4 crystalline grid, PPM output (no libpng needed)
make exceptional_grid     # Exceptional chain: E7/E6/F4/G2/S16 (PPM, no libpng)
make clean                # Remove all compiled binaries
```

---

## Tool Reference

### C Programs

All C programs use OpenMP for parallelism and process primes on the Ulam spiral.

---

#### `e8_slope_viz` -- E8 Projection Slope Visualization

Assigns each prime gap an E8 root and colors primes on the Ulam spiral by
projection slope (coolwarm colormap).  Produces PNG output directly.  Has a
built-in segmented sieve, so no prime files are needed.

```bash
# Makefile targets:
make run-viz         # 100M primes, 1200 DPI, 24" (publication quality)
make run-viz-1M      # 1M primes, 600 DPI, 16"
make run-viz-10k     # 10K primes, 300 DPI, 10", with CSV export

# Direct usage:
./e8_slope_viz --max-primes 5000000 --dpi 600 --size 16 --csv --ppm
./e8_slope_viz --max-primes 50000000 --from-files .  # load from files
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 100000000 | Number of primes to process |
| `--dpi D` | 1200 | Output resolution (dots per inch) |
| `--size S` | 24 | Image dimension in inches (S x S) |
| `--csv` | off | Export slope data to `spiral_outputs/e8_slope_data.csv` |
| `--ppm` | off | Also write PPM in addition to PNG |
| `--from-files DIR` | (sieve) | Load primes from `primesN.txt` files in DIR |

**Output:** `spiral_outputs/e8_slope_<N>.png`

**What you see:** Concentric ring patterns radiating from the center.  These are
E8 "energy levels" -- primes with similar normalized gaps cluster into bands
because they map to nearby E8 roots with similar projection slopes.

---

#### `e8_f4_viz` -- F4 Crystalline Grid (PNG, full pipeline)

Full E8-to-F4 pipeline with Salem-Jordan filtering, F4-EFT spectrum, and
crystalline vertex extraction.  Produces PNG directly.  Built-in sieve.

```bash
# Makefile targets:
make run-f4          # 100M primes, 1200 DPI, 500 vertices
make run-f4-2M       # 2M primes, 1200 DPI

# Direct usage:
./e8_f4_viz --max-primes 50000000 --dpi 1200 --size 16 --vertices 100
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 100000000 | Number of primes |
| `--dpi D` | 1200 | Output resolution |
| `--size S` | 16 | Image dimension in inches |
| `--vertices V` | 500 | Number of crystalline vertices to highlight |

**Output:** `spiral_outputs/f4_crystalline_grid_<N>.png`

---

#### `f4_crystalline_grid` -- F4 Crystalline Grid (PPM, self-contained)

Self-contained C reimplementation of the full F4 pipeline.  No libpng
dependency -- outputs raw PPM (convert to PNG with ImageMagick).  Reads primes
from text files only (no built-in sieve).

```bash
# Makefile targets:
make run-crystal        # 2M primes, 38 vertices, 6000x6000
make run-crystal-small  # 10K primes, 10 vertices, 1000x1000

# Direct usage:
./f4_crystalline_grid --max-primes 5000000 --n-vertices 50 \
    --size 8000 --output my_grid.ppm --prime-dir /path/to/primes/

# Convert to PNG:
convert f4_crystalline_grid.ppm grid.png
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 2000000 | Number of primes to load from files |
| `--n-vertices V` | 38 | Number of crystalline vertices |
| `--size S` | 6000 | Pixel dimensions (S x S) |
| `--output FILE` | `f4_crystalline_grid.ppm` | Output filename |
| `--prime-dir DIR` | `.` | Directory containing `primesN.txt` |

**Pipeline steps (matching the Python implementation exactly):**
1. Load primes from text files
2. Compute gaps and normalized gaps: `g_norm = gap / log(prime)`
3. Generate 240 E8 roots and 48 F4 roots
4. Map E8 roots to nearest F4 root by cosine similarity
5. Assign each gap an E8 root via phase map
6. Filter to F4-mapped gaps (similarity >= 0.7)
7. Compute Jordan trace `J = b1 + b2 + b3 + b4` for each F4 root
8. Compute 48-component F4-EFT spectrum
9. Score and extract top-V crystalline vertices (power + idempotent boost)
10. Render on Ulam spiral with plasma colormap (J mapped to color)
11. Draw white vertex circles with yellow edges

---

#### `exceptional_grid` -- Exceptional Chain Visualization (5 separate PPMs)

Renders separate Ulam spiral images for each sublattice in the exceptional chain
(E7, E6, F4, G2) plus the S(16) half-spinor lattice.  Selectable color scales
and a `--zoom` flag for focusing on the central region of the spiral.

```bash
# Makefile targets:
make run-exceptional        # 2M primes, 38 vertices, 6000x6000
make run-exceptional-small  # 10K primes, 10 vertices, 2000x2000

# Direct usage:
./exceptional_grid --max-primes 100000000 --n-vertices 38 --size 6000

# Zoom to central 10% of the spiral area:
./exceptional_grid --max-primes 100000000 --zoom 0.10 --size 1024

# Convert PPM to PNG:
for f in exceptional_grid_*.ppm; do convert "$f" "${f%.ppm}.png"; done
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 2000000 | Number of primes |
| `--n-vertices V` | 38 | Number of crystalline vertices |
| `--size S` | 6000 | Pixel dimensions (S x S) per image |
| `--color-scale SCALE` | auto | `auto\|jordan\|trace8\|trace2\|norm` |
| `--zoom FRAC` | 1.0 | Area fraction to show, e.g. 0.10 for central 10% |
| `--output FILE` | `exceptional_grid.ppm` | Base output filename |
| `--prime-dir DIR` | `.` | Directory containing `primesN.txt` |

**Zoom guide** -- how many primes for publication quality (1024x1024, 1200 dpi):

| Zoom | Min primes (1 pt/px) | Publication quality (5-10 pt/px) |
|-----:|---------------------:|---------------------------------:|
|  10% | 10M                  | 50M--100M                        |
|   1% | 100M                 | 500M--1B                         |
| 0.1% | 1B                   | 5B--10B                          |

**Output:** 5 files: `exceptional_grid_{E7,E6,F4,G2,S16}.ppm`

**Lattices and typical coverage at 100M primes:**

| Lattice | Roots | Coverage | Color (auto) |
|---------|------:|--------:|:-------------|
| E7      |   126 |  59.4%  | trace8 (sum of 8 coords) |
| E6      |    72 |  37.9%  | trace8 |
| F4      |    48 |  82.8%  | jordan (sum of 4 coords) |
| G2      |    12 |  68.3%  | trace2 (sum of 2 coords) |
| S(16)   |   128 |  59.6%  | trace8 |

---

### Python Analysis Scripts

---

#### `e8_f4_prime_analysis.py` -- Complete E8-F4 Analysis Pipeline

The main Python analysis script.  Performs E8 root assignment, F4 filtering,
Jordan trace computation, F4-EFT spectrum analysis, crystalline vertex
extraction, and generates four visualization images.

```bash
python3 e8_f4_prime_analysis.py
```

Key classes and functions:
- `E8Lattice` -- 240 roots in R^8, `assign_root(gap)` phase map
- `E8F4PrimeAnalyzer` -- orchestrates the full pipeline
- `E8F4Visualizer` -- matplotlib visualizations
- `ulam_coords(p)` -- O(1) Ulam spiral coordinates for prime p
- `load_primes(directory, max_primes)` -- load from `primesN.txt` files

**Output:**
| File | Description |
|------|-------------|
| `spiral_outputs/e8_f4_comparison.png` | Side-by-side E8 rings vs F4 vertices |
| `spiral_outputs/f4_crystalline_grid.png` | F4 primes with crystalline vertices |
| `spiral_outputs/f4_spectrum.png` | F4-EFT power spectrum |
| `spiral_outputs/f4_phase_analysis.png` | Phase-lock analysis |
| `spiral_outputs/statistics.txt` | F4 fraction, gap statistics |

---

#### `e8_prime_decoder.py` -- E8 Lattice Decoder

Embeds blocks of 8 consecutive primes into R^8 via normalized gap structure,
solves the closest vector problem (CVP) against the E8 lattice, and extracts
4-bit codewords via the E8/2E8 isomorphism with the extended Hamming code.

```bash
python3 e8_prime_decoder.py
```

Key functions:
- `compute_gap_embedding(primes)` -- construct 8-dimensional gap vector
- `e8_decode(gap_vector)` -- find closest E8 lattice point
- `extract_bits(lattice_point)` -- extract 4 bits via Hamming parity sums
- `bits_to_nibble(bits)` -- convert parity vector to nibble
- `load_all_primes(directory)` -- load all primes from `primesN.txt`

**Output:**
| File | Description |
|------|-------------|
| `spiral_outputs/decoded_bits.bin` | Raw extracted bits |
| `spiral_outputs/decoding_errors.npy` | Per-block CVP error distances |
| `spiral_outputs/lattice_points.npy` | Closest E8 lattice points |

---

#### `e8_multi_decoder.py` -- Multi-Method Decoder

Comprehensive decoder that tries 12 extraction methods simultaneously across
5 groups, with first-N filtered variants, producing 53 total decoding attempts.
For each method, reports entropy, chi-square p-value, and longest printable
ASCII run.

```bash
# Makefile target:
make run-decoder         # 2M primes

# Direct usage:
python3 e8_multi_decoder.py --max-primes 50000000 --output results.txt
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 2000000 | Number of primes |
| `--output FILE` | `decoder_results.txt` | Results filename (in `spiral_outputs/`) |

**Method groups:**

| Group | Methods | Bits/block |
|-------|---------|-----------|
| 1. E8 Lattice | Hamming 4-bit, sign bits, sublattice flag, parity | 4, 8, 1, 8 |
| 2. E8 Root | Root index mod 256, projection slope | 8, 8 |
| 3. Raw Gap | Gap as ASCII, normalized gap quantized | 8, 8 |
| 4. F4 Sub-harmonic | F4 root index, Jordan trace bits | 6, 4 |
| 5. Crystalline | Vertex gap values, spacing, primes | variable |

Each base method is also run on first-100, first-1000, and first-10000 blocks.

**Output:** `spiral_outputs/decoder_results.txt` -- ranked summary of all 53 methods

---

#### `f4_lattice.py` -- F4 Root System Module

Generates the 48 F4 roots in R^4, builds the E8-to-F4 mapping via cosine
similarity, and precomputes F4 characters for the EFT.

Key class: `F4Lattice`
- `_generate_f4_roots_4d()` -- 24 long (norm sqrt(2)) + 24 short (norm 1)
- `_build_e8_mapping()` -- maps each of 240 E8 roots to nearest F4 root
- `is_f4_root(e8_idx)` -- True if cosine similarity >= 0.7
- `_precompute_characters()` -- chi_k for EFT weighting

Imported by: `e8_f4_prime_analysis.py`, `e8_multi_decoder.py`, `f4_eft.py`

---

#### `f4_eft.py` -- F4 Exceptional Fourier Transform

Computes the 48-component F4-EFT complex spectrum and extracts crystalline
vertices by resonance score.

Key classes and functions:
- `F4ExceptionalFourierTransform` -- `.compute()` returns complex spectrum
- `extract_crystalline_pattern(analyzer, n_vertices)` -- top-V by power + idempotent boost

Imported by: `e8_f4_prime_analysis.py`, `e8_multi_decoder.py`

---

#### `exceptional_analysis.py` -- Exceptional Chain Analysis (Python)

Multi-lattice orchestrator for prime gap analysis through the complete
exceptional chain G2 < F4 < E6 < E7 < E8 plus S(16).  Produces a 3x2 panel
matplotlib visualization with per-lattice Ulam spirals and a summary panel.

```bash
# Makefile target:
make run-exceptional-analysis  # 2M primes

# Direct usage:
python3 exceptional_analysis.py --max-primes 2000000 --color-scale auto
```

| Flag | Default | Description |
|------|---------|-------------|
| `--max-primes N` | 2000000 | Number of primes |
| `--color-scale SCALE` | auto | `auto\|jordan\|trace8\|trace2\|norm` |
| `--output FILE` | auto | Output image path |

**Output:** `spiral_outputs/exceptional_chain.png`

---

#### `e7_lattice.py` / `e6_lattice.py` / `g2_lattice.py` / `s16_lattice.py` -- Sublattice Modules

Root system modules for the exceptional chain sublattices.  Each follows the
same class pattern as `f4_lattice.py`.

| Module | Class | Roots | Dimension | Construction |
|--------|-------|------:|----------:|:-------------|
| `e7_lattice.py` | `E7Lattice` | 126 | R^8 | E8 roots with v₀ = v₁ |
| `e6_lattice.py` | `E6Lattice` | 72 | R^8 | E8 roots with v₀ = v₁ = v₂ |
| `g2_lattice.py` | `G2Lattice` | 12 | R^2 | 6 short (norm 1) + 6 long (norm √3) |
| `s16_lattice.py` | `S16Lattice` | 128 | R^8 | Type II E8 roots: (±½)^8, even neg |

Common API: `is_XX_root(e8_idx)`, `project_e8_to_XX(e8_idx)`,
`get_projection_quality(e8_idx)`, `jordan_trace(idx)`, `root_norm(idx)`,
`summary()`.

Imported by: `exceptional_analysis.py`, `exceptional_grid.c` (via `e8_common.h`),
`e8_multi_decoder.py`

---

#### `jordan_algebra.py` -- Jordan Algebra and Octonions

Implements the Albert algebra (exceptional Jordan algebra J_3(O) of 3x3
Hermitian matrices over the octonions), the Jordan trace functional, and
octonion multiplication.

Key classes:
- `Octonion` -- 8-dimensional normed division algebra with Cayley-Dickson multiplication
- `JordanTrace` -- trace = sum of F4 root coordinates via projection `P`
- `AlbertElement` -- 3x3 Hermitian octonion matrices with Jordan product

Imported by: `e8_f4_prime_analysis.py`, `f4_eft.py`, `e8_multi_decoder.py`

---

#### `salem_jordan.py` -- Salem-Jordan Kernel Filter

Fermi-Dirac thermal filter for smoothing the F4-EFT spectrum.

Kernel: `K_J(m, tau) = (52 - 4m^2)/52 * 1/(exp(m/tau) + 1)`

Key class: `SalemJordanKernel`

Imported by: `e8_f4_prime_analysis.py`, `f4_eft.py`

---

#### `e8_slope_coloring.py` -- E8 Slope Visualization (Python)

Original Python implementation of the E8 slope coloring on the Ulam spiral.
Superseded by `e8_slope_viz` (C) for large prime counts but useful for quick
prototyping and parameter exploration.

```bash
python3 e8_slope_coloring.py
```

**Output:** `spiral_outputs/e8_projection_slope_<N>_<DPI>dpi_dark.png`

---

#### `e8_visualizer.py` / `e8_decoder_companion.py` -- Visualization Helpers

Post-processing visualization from pickled E8 decoding results.  Load
`e8_decoding_results.pkl` (produced by `e8_decoderring.py`) and generate
diagnostic plots.

```bash
python3 e8_visualizer.py
python3 e8_decoder_companion.py
```

---

#### `e8_decoderring.py` -- High-Precision Decoder (gmpy2)

Alternative E8 decoder using gmpy2 for arbitrary-precision arithmetic.
Includes FFT-based spectral analysis and comprehensive statistical tests.

```bash
pip install gmpy2 tqdm
python3 e8_decoderring.py
```

---

### Python Utility Scripts

---

#### `split_primes.py` -- Split Bulk Primes into Files

Converts a single `all_primes.txt` (one prime per line, from primesieve)
into 50 files of 2M primes each in t5k.org format.

```bash
primesieve 2038074743 --print > all_primes.txt
python3 split_primes.py
```

---

#### `convert_primes.py` -- Convert to CSV Format

Converts prime text files to CSV with columns: Rank, Num, Interval (gap to
next prime).

```bash
python3 convert_primes.py
```

---

### SageMath Scripts

---

#### `e8_prime_decode.sage` / `e8_prime_decode_v2.sage`

Lattice-theoretic E8 decoding using SageMath's built-in lattice closest vector
solver.  More mathematically rigorous than the numpy-based decoder.  v2 adds
additional analysis.

```bash
sage e8_prime_decode.sage
sage e8_prime_decode_v2.sage
```

---

## Shared Header: `e8_common.h`

Common C header used by `e8_slope_viz.c`, `e8_f4_viz.c`, and
`exceptional_grid.c`, providing:
- E8 root generation (240 roots: 112 Type I + 128 Type II)
- F4 root generation (48 roots in R^4)
- E7 root generation (126 roots in R^8, v₀ = v₁ constraint)
- E6 root generation (72 roots in R^8, v₀ = v₁ = v₂ constraint)
- G2 root generation (12 roots in R^2, angle formula)
- S(16) half-spinor root generation (128 roots, Type II E8 subset)
- E8-to-sublattice mappings (exact membership + cosine similarity)
- Segmented prime sieve
- Prime file loading
- Ulam spiral coordinate computation (O(1) per prime)
- Plasma and HSV colormaps
- Configurable color scale helper (`jordan_to_color_range`)
- OpenMP timing macros (`tic()` / `toc()`)

Not used by `f4_crystalline_grid.c`, which is fully self-contained.

---

## Workflow Examples

### 1. Quick start -- small E8 slope image

```bash
make e8_slope_viz
make run-viz-10k
# Output: spiral_outputs/e8_slope_10k.png (~10K primes, fast)
```

### 2. F4 crystalline grid at 2M primes (PPM path)

```bash
make f4_crystalline_grid
make run-crystal
convert f4_crystalline_grid.ppm grid.png
# Output: grid.png (6000x6000, plasma colormap, 38 vertices)
```

### 3. F4 crystalline grid at 100M primes (PNG path)

```bash
make e8_f4_viz
make run-f4
# Output: spiral_outputs/f4_crystalline_grid_100M.png
```

### 4. Run all decoders on 2M primes

```bash
make run-decoder
# Output: spiral_outputs/decoder_results.txt (53 methods ranked)
```

### 5. Full Python analysis pipeline

```bash
python3 e8_f4_prime_analysis.py
# Output: e8_f4_comparison.png, f4_crystalline_grid.png,
#         f4_spectrum.png, f4_phase_analysis.png, statistics.txt
```

### 6. Custom run from scratch

```bash
# 1. Generate prime data
primesieve 1000000000 --print > all_primes.txt
python3 split_primes.py

# 2. Build and run C visualizer
make f4_crystalline_grid
./f4_crystalline_grid --max-primes 10000000 --n-vertices 100 \
    --size 8000 --output custom.ppm
convert custom.ppm custom.png

# 3. Run multi-method decoder
python3 e8_multi_decoder.py --max-primes 10000000

# 4. Full Python analysis
python3 e8_f4_prime_analysis.py
```

### 7. Exceptional chain comparison at 100M primes

```bash
make exceptional_grid
./exceptional_grid --max-primes 100000000 --n-vertices 38
for f in exceptional_grid_*.ppm; do convert "$f" "${f%.ppm}.png"; done
# Output: exceptional_grid_{E7,E6,F4,G2,S16}.png (5 images, 6000x6000)
```

### 8. Zoomed view of central 10%

```bash
./exceptional_grid --max-primes 100000000 --zoom 0.10 --size 1024 \
    --output zoom10.ppm
for f in zoom10_*.ppm; do convert "$f" "${f%.ppm}.png"; done
```

### 9. Publication-quality images

```bash
# E8 slope at 100M primes (produces ~50 MB PNG)
make run-viz

# F4 grid at 100M primes
make run-f4

# Both produce 1200 DPI output suitable for print
```

---

## Output Files

All generated images and data go to `spiral_outputs/` (created automatically).

| File | Source | Description |
|------|--------|-------------|
| `e8_slope_<N>.png` | `e8_slope_viz` | E8 projection slope, Ulam spiral |
| `e8_slope_<N>.ppm` | `e8_slope_viz --ppm` | Same, PPM format |
| `e8_slope_data.csv` | `e8_slope_viz --csv` | Per-prime slope data |
| `f4_crystalline_grid_<N>.png` | `e8_f4_viz` | F4 grid with vertices, PNG |
| `f4_crystalline_grid.ppm` | `f4_crystalline_grid` | F4 grid, PPM format |
| `e8_f4_comparison.png` | Python pipeline | Side-by-side E8 vs F4 |
| `f4_spectrum.png` | Python pipeline | F4-EFT power spectrum |
| `f4_phase_analysis.png` | Python pipeline | Phase distribution |
| `statistics.txt` | Python pipeline | Coverage and gap statistics |
| `exceptional_chain.png` | `exceptional_analysis.py` | 3x2 panel: E7/E6/F4/G2/S16 + summary |
| `exceptional_grid_{E7,E6,F4,G2,S16}.ppm` | `exceptional_grid` | Per-lattice Ulam spirals |
| `decoder_results.txt` | `e8_multi_decoder.py` | All 53 decoder methods ranked |
| `decoded_bits.bin` | `e8_prime_decoder.py` | Raw extracted bits |
| `decoding_errors.npy` | `e8_prime_decoder.py` | Per-block CVP errors |
| `lattice_points.npy` | `e8_prime_decoder.py` | Closest E8 lattice points |

---

## Mathematics Overview

### E8 Root System (240 roots in R^8)

- **Type I** (112 roots): all vectors `+/- e_i +/- e_j` for `i < j`
  (28 pairs x 4 sign combinations)
- **Type II** (128 roots): all vectors `(+/- 1/2)^8` with an even number of
  minus signs

### E8 Root Assignment

Each prime gap `g_i = p_{i+1} - p_i` is normalized:
```
g_norm = g_i / log(p_i)
```
A phase is computed and mapped to one of 240 roots:
```
phase = (sqrt(max(g_norm, 0.01)) / sqrt(2)) mod 1
root_index = floor(240 * phase) mod 240
```

### Exceptional Chain: G2 < F4 < E6 < E7 < E8

The 240 E8 roots decompose into sublattices corresponding to the exceptional
Lie group chain.  Each sublattice filters prime gaps by algebraic structure.

| Lattice | Roots | Constraint | Typical coverage |
|---------|------:|:-----------|:-----------------|
| E8      |   240 | (full)     | 100%             |
| E7      |   126 | v₀ = v₁    | ~59%             |
| E6      |    72 | v₀ = v₁ = v₂ | ~38%          |
| F4      |    48 | 4D projection | ~83%           |
| G2      |    12 | 2D projection | ~68%           |
| S(16)   |   128 | Type II (half-int) | ~60%      |

S(16) is the half-spinor representation of Spin(16), complementary to the
exceptional chain: the 240 E8 roots = 112 D8 vector roots + 128 S⁺(16).

### F4 Root System (48 roots in R^4)

- **24 long roots** (norm sqrt(2)): `+/- e_i +/- e_j` for `i < j`
- **8 short roots** (norm 1): `+/- e_i`
- **8 short roots type B**: `(+/- 1/2)^4` with even number of negatives
- **8 short roots type C**: `(+/- 1/2)^4` with odd number of negatives

### E8-to-F4 Projection

Each E8 root's first 4 coordinates are projected and matched to the nearest F4
root by cosine similarity.  All 240 E8 roots achieve similarity 1.0 -- this is
the **Complete F4 Coverage Theorem** (proved by case analysis on root types).

### Jordan Trace

For an F4 root `beta = (b1, b2, b3, b4)`:
```
J(beta) = b1 + b2 + b3 + b4
```
This is the trace of the diagonal of the Albert algebra projection matrix
applied to the root.  Values range from -2 to +2.

Classification by Jordan trace:
- `|J| > 1`: regular elements (bulk)
- `|J| ~ 1`: idempotents (fixed points of Albert algebra)
- `|J| ~ 0`: nilpotents (transitional)

### F4-EFT Spectrum

A 48-component complex Fourier transform.  Each F4 root index `k` accumulates
contributions from all gaps mapped to it:
```
S_k = sum_{n -> k} (g_norm[n] - 1) * chi_k * exp(2*pi*i * ||r_k|| / sqrt(2) * n / N)
```
where `chi_k` is the F4 character (long roots: `2(1 + 0.1h)`, short roots:
`1(1 + 0.1h)`).  The power spectrum `|S_k|^2` identifies resonant F4 modes.

### Crystalline Vertices

Gaps are scored by their F4-EFT power, with a 2x boost for idempotent roots
(`|J|` close to 1).  The top-V scoring gaps become crystalline vertices, drawn
as white circles with yellow edges on the Ulam spiral.

### Plasma Colormap

Jordan trace values are mapped from `[-2, +2]` to `[0, 255]` and colored via
a 256-entry RGB lookup table matching matplotlib's `plasma` colormap (dark
purple for most negative, yellow for most positive).

---

## Troubleshooting

### "Not enough primes loaded"

Ensure prime files exist in the working directory:
```bash
ls primes*.txt | head
```

### Out of memory

Reduce `--max-primes` or `--size`.  Memory usage scales roughly as:
- 8 bytes/prime (storage) + 8 bytes/gap (normalized) + image buffer
- At 2M primes, 6000x6000 image: ~200 MB total
- At 100M primes, 1200 DPI: ~4-8 GB

### PPM files are huge

PPM is uncompressed.  Convert to PNG immediately:
```bash
convert output.ppm output.png
rm output.ppm
```

### libpng not found

Install the development package:
```bash
sudo apt install libpng-dev    # Debian/Ubuntu
sudo dnf install libpng-devel  # Fedora
```

If you don't want to install libpng, use `f4_crystalline_grid` (PPM output,
no libpng needed) instead of `e8_f4_viz` (PNG output).

---

## Documentation

- `docs/e8_prime_structure.tex` -- Full manuscript (22 pages) with all
  algorithms, proofs, and computational results
- `docs/entropy_production_rate.tex` -- Entropy production analysis

## References

1. Ulam, S. (1963). "A Visual Representation of the Distribution of Primes"
2. Conway & Sloane (1999). "Sphere Packings, Lattices and Groups"
3. Viazovska, M. (2017). "The sphere packing problem in dimension 8"
